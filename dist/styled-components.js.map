{"version":3,"file":"styled-components.js","sources":["../src/constants.js","../src/sheet/Tag.js","../src/sheet/GroupedTag.js","../src/sheet/GroupIDAllocator.js","../src/sheet/Sheet.js","../src/models/StyleSheetManager.js","../src/utils/isStaticRules.js","../src/models/GlobalStyle.js","../src/constructors/createGlobalStyle.js","../src/models/ServerStyleSheet.js","../src/base.js","../src/models/ComponentStyle.js","../src/models/StyledComponent.js"],"sourcesContent":["// @flow\r\n\r\ndeclare var SC_DISABLE_SPEEDY: ?boolean;\r\ndeclare var __VERSION__: string;\r\n\r\nexport const SC_ATTR =\r\n  (typeof process !== 'undefined' && (process.env.REACT_APP_SC_ATTR || process.env.SC_ATTR)) ||\r\n  'data-styled';\r\n\r\nexport const SC_ATTR_ACTIVE = 'active';\r\nexport const SC_ATTR_VERSION = 'data-styled-version';\r\nexport const SC_VERSION = __VERSION__;\r\nexport const SPLITTER = '/*!sc*/\\n';\r\n\r\nexport const IS_BROWSER = typeof window !== 'undefined' && 'HTMLElement' in window;\r\n\r\nexport const DISABLE_SPEEDY =\r\n  (typeof SC_DISABLE_SPEEDY === 'boolean' && SC_DISABLE_SPEEDY) ||\r\n  (typeof process !== 'undefined' &&\r\n    (process.env.REACT_APP_SC_DISABLE_SPEEDY || process.env.SC_DISABLE_SPEEDY)) ||\r\n  process.env.NODE_ENV !== 'production';\r\n\r\n// Shared empty execution context when generating static styles\r\nexport const STATIC_EXECUTION_CONTEXT = {};\r\n","// @flow\r\n/* eslint-disable no-use-before-define */\r\n\r\nimport { makeStyleTag, getSheet } from './dom';\r\nimport type { SheetOptions, Tag } from './types';\r\n\r\n/** Create a CSSStyleSheet-like tag depending on the environment */\r\nexport const makeTag = ({ isServer, useCSSOMInjection, target }: SheetOptions): Tag => {\r\n  if (isServer) {\r\n    return new VirtualTag(target);\r\n  } else if (useCSSOMInjection) {\r\n    return new CSSOMTag(target);\r\n  } else {\r\n    return new TextTag(target);\r\n  }\r\n};\r\n\r\nexport class CSSOMTag implements Tag {\r\n  element: HTMLStyleElement;\r\n\r\n  sheet: CSSStyleSheet;\r\n\r\n  length: number;\r\n\r\n  constructor(target?: HTMLElement) {\r\n    const element = (this.element = makeStyleTag(target));\r\n\r\n    // Avoid Edge bug where empty style elements don't create sheets\r\n    element.appendChild(document.createTextNode(''));\r\n\r\n    this.sheet = getSheet(element);\r\n    this.length = 0;\r\n  }\r\n\r\n  insertRule(index: number, rule: string): boolean {\r\n    try {\r\n      this.sheet.insertRule(rule, index);\r\n      this.length++;\r\n      return true;\r\n    } catch (_error) {\r\n      return false;\r\n    }\r\n  }\r\n\r\n  deleteRule(index: number): void {\r\n    this.sheet.deleteRule(index);\r\n    this.length--;\r\n  }\r\n\r\n  getRule(index: number): string {\r\n    const rule = this.sheet.cssRules[index];\r\n    // Avoid IE11 quirk where cssText is inaccessible on some invalid rules\r\n    if (rule !== undefined && typeof rule.cssText === 'string') {\r\n      return rule.cssText;\r\n    } else {\r\n      return '';\r\n    }\r\n  }\r\n}\r\n\r\n/** A Tag that emulates the CSSStyleSheet API but uses text nodes */\r\nexport class TextTag implements Tag {\r\n  element: HTMLStyleElement;\r\n\r\n  nodes: NodeList<Node>;\r\n\r\n  length: number;\r\n\r\n  constructor(target?: HTMLElement) {\r\n    const element = (this.element = makeStyleTag(target));\r\n    this.nodes = element.childNodes;\r\n    this.length = 0;\r\n  }\r\n\r\n  insertRule(index: number, rule: string): boolean {\r\n    if (index <= this.length && index >= 0) {\r\n      const node = document.createTextNode(rule);\r\n      const refNode = this.nodes[index];\r\n      this.element.insertBefore(node, refNode || null);\r\n      this.length++;\r\n      return true;\r\n    } else {\r\n      return false;\r\n    }\r\n  }\r\n\r\n  deleteRule(index: number): void {\r\n    this.element.removeChild(this.nodes[index]);\r\n    this.length--;\r\n  }\r\n\r\n  getRule(index: number): string {\r\n    if (index < this.length) {\r\n      return this.nodes[index].textContent;\r\n    } else {\r\n      return '';\r\n    }\r\n  }\r\n}\r\n\r\n/** A completely virtual (server-side) Tag that doesn't manipulate the DOM */\r\nexport class VirtualTag implements Tag {\r\n  rules: string[];\r\n\r\n  length: number;\r\n\r\n  constructor(_target?: HTMLElement) {\r\n    this.rules = [];\r\n    this.length = 0;\r\n  }\r\n\r\n  insertRule(index: number, rule: string): boolean {\r\n    if (index <= this.length) {\r\n      this.rules.splice(index, 0, rule);\r\n      this.length++;\r\n      return true;\r\n    } else {\r\n      return false;\r\n    }\r\n  }\r\n\r\n  deleteRule(index: number): void {\r\n    this.rules.splice(index, 1);\r\n    this.length--;\r\n  }\r\n\r\n  getRule(index: number): string {\r\n    if (index < this.length) {\r\n      return this.rules[index];\r\n    } else {\r\n      return '';\r\n    }\r\n  }\r\n}\r\n","// @flow\r\n/* eslint-disable no-use-before-define */\r\n\r\nimport type { GroupedTag, Tag } from './types';\r\nimport { SPLITTER } from '../constants';\r\nimport throwStyledError from '../utils/error';\r\n\r\n/** Create a GroupedTag with an underlying Tag implementation */\r\nexport const makeGroupedTag = (tag: Tag): GroupedTag => {\r\n  return new DefaultGroupedTag(tag);\r\n};\r\n\r\nconst BASE_SIZE = 1 << 9;\r\n\r\nclass DefaultGroupedTag implements GroupedTag {\r\n  groupSizes: Uint32Array;\r\n\r\n  length: number;\r\n\r\n  tag: Tag;\r\n\r\n  constructor(tag: Tag) {\r\n    this.groupSizes = new Uint32Array(BASE_SIZE);\r\n    this.length = BASE_SIZE;\r\n    this.tag = tag;\r\n  }\r\n\r\n  indexOfGroup(group: number): number {\r\n    let index = 0;\r\n    for (let i = 0; i < group; i++) {\r\n      index += this.groupSizes[i];\r\n    }\r\n\r\n    return index;\r\n  }\r\n\r\n  insertRules(group: number, rules: string[]): void {\r\n    if (group >= this.groupSizes.length) {\r\n      const oldBuffer = this.groupSizes;\r\n      const oldSize = oldBuffer.length;\r\n\r\n      let newSize = oldSize;\r\n      while (group >= newSize) {\r\n        newSize <<= 1;\r\n        if (newSize < 0) {\r\n          throwStyledError(16, `${group}`);\r\n        }\r\n      }\r\n\r\n      this.groupSizes = new Uint32Array(newSize);\r\n      this.groupSizes.set(oldBuffer);\r\n      this.length = newSize;\r\n\r\n      for (let i = oldSize; i < newSize; i++) {\r\n        this.groupSizes[i] = 0;\r\n      }\r\n    }\r\n\r\n    let ruleIndex = this.indexOfGroup(group + 1);\r\n    for (let i = 0, l = rules.length; i < l; i++) {\r\n      if (this.tag.insertRule(ruleIndex, rules[i])) {\r\n        this.groupSizes[group]++;\r\n        ruleIndex++;\r\n      }\r\n    }\r\n  }\r\n\r\n  clearGroup(group: number): void {\r\n    if (group < this.length) {\r\n      const length = this.groupSizes[group];\r\n      const startIndex = this.indexOfGroup(group);\r\n      const endIndex = startIndex + length;\r\n\r\n      this.groupSizes[group] = 0;\r\n\r\n      for (let i = startIndex; i < endIndex; i++) {\r\n        this.tag.deleteRule(startIndex);\r\n      }\r\n    }\r\n  }\r\n\r\n  getGroup(group: number): string {\r\n    let css = '';\r\n    if (group >= this.length || this.groupSizes[group] === 0) {\r\n      return css;\r\n    }\r\n\r\n    const length = this.groupSizes[group];\r\n    const startIndex = this.indexOfGroup(group);\r\n    const endIndex = startIndex + length;\r\n\r\n    for (let i = startIndex; i < endIndex; i++) {\r\n      css += `${this.tag.getRule(i)}${SPLITTER}`;\r\n    }\r\n\r\n    return css;\r\n  }\r\n}\r\n","// @flow\r\n\r\nimport throwStyledError from '../utils/error';\r\n\r\nconst MAX_SMI = 1 << 31 - 1;\r\n\r\nlet groupIDRegister: Map<string, number> = new Map();\r\nlet reverseRegister: Map<number, string> = new Map();\r\nlet nextFreeGroup = 1;\r\n\r\nexport const resetGroupIds = () => {\r\n  groupIDRegister = new Map();\r\n  reverseRegister = new Map();\r\n  nextFreeGroup = 1;\r\n};\r\n\r\nexport const getGroupForId = (id: string): number => {\r\n  if (groupIDRegister.has(id)) {\r\n    return (groupIDRegister.get(id): any);\r\n  }\r\n\r\n  const group = nextFreeGroup++;\r\n  if (\r\n    process.env.NODE_ENV !== 'production' &&\r\n    ((group | 0) < 0 || group > MAX_SMI)\r\n  ) {\r\n    throwStyledError(16, `${group}`);\r\n  }\r\n\r\n  groupIDRegister.set(id, group);\r\n  reverseRegister.set(group, id);\r\n\r\n  return group;\r\n};\r\n\r\nexport const getIdForGroup = (group: number): void | string => {\r\n  return reverseRegister.get(group);\r\n};\r\n\r\nexport const setGroupForId = (id: string, group: number) => {\r\n  if (group >= nextFreeGroup) {\r\n    nextFreeGroup = group + 1;\r\n  }\r\n\r\n  groupIDRegister.set(id, group);\r\n  reverseRegister.set(group, id);\r\n};\r\n","// @flow\r\nimport { DISABLE_SPEEDY, IS_BROWSER } from '../constants';\r\nimport type { GroupedTag, Sheet, SheetOptions } from './types';\r\nimport { makeTag } from './Tag';\r\nimport { makeGroupedTag } from './GroupedTag';\r\nimport { getGroupForId } from './GroupIDAllocator';\r\nimport { outputSheet, rehydrateSheet } from './Rehydration';\r\n\r\nlet SHOULD_REHYDRATE = IS_BROWSER;\r\n\r\ntype SheetConstructorArgs = {\r\n  isServer?: boolean,\r\n  useCSSOMInjection?: boolean,\r\n  target?: HTMLElement,\r\n};\r\n\r\ntype GlobalStylesAllocationMap = { [key: string]: number };\r\ntype NamesAllocationMap = Map<string, Set<string>>;\r\n\r\nconst defaultOptions = {\r\n  isServer: !IS_BROWSER,\r\n  useCSSOMInjection: !DISABLE_SPEEDY,\r\n};\r\n\r\n/** Contains the main stylesheet logic for stringification and caching */\r\nexport default class StyleSheet implements Sheet {\r\n  gs: GlobalStylesAllocationMap;\r\n\r\n  names: NamesAllocationMap;\r\n\r\n  options: SheetOptions;\r\n\r\n  tag: void | GroupedTag;\r\n\r\n  /** Register a group ID to give it an index */\r\n  static registerId(id: string): number {\r\n    return getGroupForId(id);\r\n  }\r\n\r\n  constructor(\r\n    options: SheetConstructorArgs = defaultOptions,\r\n    globalStyles?: GlobalStylesAllocationMap = {},\r\n    names?: NamesAllocationMap\r\n  ) {\r\n    this.options = {\r\n      ...defaultOptions,\r\n      ...options,\r\n    };\r\n\r\n    this.gs = globalStyles;\r\n    this.names = new Map(names);\r\n\r\n    // We rehydrate only once and use the sheet that is created first\r\n    if (!this.options.isServer && IS_BROWSER && SHOULD_REHYDRATE) {\r\n      SHOULD_REHYDRATE = false;\r\n      rehydrateSheet(this);\r\n    }\r\n  }\r\n\r\n  reconstructWithOptions(options: SheetConstructorArgs) {\r\n    return new StyleSheet({ ...this.options, ...options }, this.gs, this.names);\r\n  }\r\n\r\n  allocateGSInstance(id: string) {\r\n    return (this.gs[id] = (this.gs[id] || 0) + 1);\r\n  }\r\n\r\n  /** Lazily initialises a GroupedTag for when it's actually needed */\r\n  getTag(): GroupedTag {\r\n    return this.tag || (this.tag = makeGroupedTag(makeTag(this.options)));\r\n  }\r\n\r\n  /** Check whether a name is known for caching */\r\n  hasNameForId(id: string, name: string): boolean {\r\n    return this.names.has(id) && (this.names.get(id): any).has(name);\r\n  }\r\n\r\n  /** Mark a group's name as known for caching */\r\n  registerName(id: string, name: string) {\r\n    getGroupForId(id);\r\n\r\n    if (!this.names.has(id)) {\r\n      const groupNames = new Set();\r\n      groupNames.add(name);\r\n      this.names.set(id, groupNames);\r\n    } else {\r\n      (this.names.get(id): any).add(name);\r\n    }\r\n  }\r\n\r\n  /** Insert new rules which also marks the name as known */\r\n  insertRules(id: string, name: string, rules: string[]) {\r\n    this.registerName(id, name);\r\n    this.getTag().insertRules(getGroupForId(id), rules);\r\n  }\r\n\r\n  /** Clears all cached names for a given group ID */\r\n  clearNames(id: string) {\r\n    if (this.names.has(id)) {\r\n      (this.names.get(id): any).clear();\r\n    }\r\n  }\r\n\r\n  /** Clears all rules for a given group ID */\r\n  clearRules(id: string) {\r\n    this.getTag().clearGroup(getGroupForId(id));\r\n    this.clearNames(id);\r\n  }\r\n\r\n  /** Clears the entire tag which deletes all rules but not its names */\r\n  clearTag() {\r\n    // NOTE: This does not clear the names, since it's only used during SSR\r\n    // so that we can continuously output only new rules\r\n    this.tag = undefined;\r\n  }\r\n\r\n  /** Outputs the current sheet as a CSS string with markers for SSR */\r\n  toString(): string {\r\n    return outputSheet(this);\r\n  }\r\n}\r\n","// @flow\r\nimport React, { useContext, useEffect, useMemo, useState, type Node, type Context } from 'react';\r\nimport shallowequal from 'shallowequal';\r\nimport StyleSheet from '../sheet';\r\nimport createStylisInstance, { type Stringifier } from '../utils/stylis';\r\n\r\ntype Props = {\r\n  children?: Node,\r\n  disableCSSOMInjection?: boolean,\r\n  disableVendorPrefixes?: boolean,\r\n  sheet?: StyleSheet,\r\n  stylisPlugins?: Array<Function>,\r\n  target?: HTMLElement,\r\n};\r\n\r\nexport const StyleSheetContext: Context<StyleSheet | void> = React.createContext();\r\nexport const StyleSheetConsumer = StyleSheetContext.Consumer;\r\nexport const StylisContext: Context<Stringifier | void> = React.createContext();\r\nexport const StylisConsumer = StylisContext.Consumer;\r\n\r\nexport const masterSheet: StyleSheet = new StyleSheet();\r\nexport const masterStylis: Stringifier = createStylisInstance();\r\n\r\nexport function useStyleSheet(): StyleSheet {\r\n  return useContext(StyleSheetContext) || masterSheet;\r\n}\r\n\r\nexport function useStylis(): Stringifier {\r\n  return useContext(StylisContext) || masterStylis;\r\n}\r\n\r\nexport default function StyleSheetManager(props: Props) {\r\n  const [plugins, setPlugins] = useState(props.stylisPlugins);\r\n  const contextStyleSheet = useStyleSheet();\r\n\r\n  const styleSheet = useMemo(() => {\r\n    let sheet = contextStyleSheet;\r\n\r\n    if (props.sheet) {\r\n      // eslint-disable-next-line prefer-destructuring\r\n      sheet = props.sheet;\r\n    } else if (props.target) {\r\n      sheet = sheet.reconstructWithOptions({ target: props.target });\r\n    }\r\n\r\n    if (props.disableCSSOMInjection) {\r\n      sheet = sheet.reconstructWithOptions({ useCSSOMInjection: false });\r\n    }\r\n\r\n    return sheet;\r\n  }, [props.disableCSSOMInjection, props.sheet, props.target]);\r\n\r\n  const stylis = useMemo(\r\n    () =>\r\n      createStylisInstance({\r\n        options: { prefix: !props.disableVendorPrefixes },\r\n        plugins,\r\n      }),\r\n    [props.disableVendorPrefixes, plugins]\r\n  );\r\n\r\n  useEffect(() => {\r\n    if (!shallowequal(plugins, props.stylisPlugins)) setPlugins(props.stylisPlugins);\r\n  }, [props.stylisPlugins]);\r\n\r\n  return (\r\n    <StyleSheetContext.Provider value={styleSheet}>\r\n      <StylisContext.Provider value={stylis}>\r\n        {process.env.NODE_ENV !== 'production'\r\n          ? React.Children.only(props.children)\r\n          : props.children}\r\n      </StylisContext.Provider>\r\n    </StyleSheetContext.Provider>\r\n  );\r\n}\r\n","// @flow\r\nimport isFunction from './isFunction';\r\nimport isStyledComponent from './isStyledComponent';\r\nimport type { RuleSet } from '../types';\r\n\r\nexport default function isStaticRules(rules: RuleSet): boolean {\r\n  for (let i = 0; i < rules.length; i += 1) {\r\n    const rule = rules[i];\r\n\r\n    if (isFunction(rule) && !isStyledComponent(rule)) {\r\n      // functions are allowed to be static if they're just being\r\n      // used to get the classname of a nested styled component\r\n      return false;\r\n    }\r\n  }\r\n\r\n  return true;\r\n}\r\n","// @flow\r\nimport flatten from '../utils/flatten';\r\nimport isStaticRules from '../utils/isStaticRules';\r\nimport StyleSheet from '../sheet';\r\n\r\nimport type { RuleSet, Stringifier } from '../types';\r\n\r\nexport default class GlobalStyle {\r\n  componentId: string;\r\n\r\n  isStatic: boolean;\r\n\r\n  rules: RuleSet;\r\n\r\n  constructor(rules: RuleSet, componentId: string) {\r\n    this.rules = rules;\r\n    this.componentId = componentId;\r\n    this.isStatic = isStaticRules(rules);\r\n  }\r\n\r\n  createStyles(\r\n    instance: number,\r\n    executionContext: Object,\r\n    styleSheet: StyleSheet,\r\n    stylis: Stringifier\r\n  ) {\r\n    const flatCSS = flatten(this.rules, executionContext, styleSheet);\r\n    const css = stylis(flatCSS.join(''), '');\r\n    const id = this.componentId + instance;\r\n\r\n    // NOTE: We use the id as a name as well, since these rules never change\r\n\r\n    styleSheet.insertRules(id, id, css);\r\n  }\r\n\r\n  removeStyles(instance: number, styleSheet: StyleSheet) {\r\n    styleSheet.clearRules(this.componentId + instance);\r\n  }\r\n\r\n  renderStyles(\r\n    instance: number,\r\n    executionContext: Object,\r\n    styleSheet: StyleSheet,\r\n    stylis: Stringifier\r\n  ) {\r\n    StyleSheet.registerId(this.componentId + instance);\r\n\r\n    // NOTE: Remove old styles, then inject the new ones\r\n    this.removeStyles(instance, styleSheet);\r\n    this.createStyles(instance, executionContext, styleSheet, stylis);\r\n  }\r\n}\r\n","// @flow\r\nimport React, { useContext, useEffect, useRef } from 'react';\r\nimport { STATIC_EXECUTION_CONTEXT } from '../constants';\r\nimport GlobalStyle from '../models/GlobalStyle';\r\nimport { useStyleSheet, useStylis } from '../models/StyleSheetManager';\r\nimport { checkDynamicCreation } from '../utils/checkDynamicCreation';\r\nimport determineTheme from '../utils/determineTheme';\r\nimport { ThemeContext } from '../models/ThemeProvider';\r\nimport { EMPTY_ARRAY } from '../utils/empties';\r\nimport generateComponentId from '../utils/generateComponentId';\r\nimport css from './css';\r\n\r\nimport type { Interpolation } from '../types';\r\n\r\ntype GlobalStyleComponentPropsType = Object;\r\n\r\nexport default function createGlobalStyle(\r\n  strings: Array<string>,\r\n  ...interpolations: Array<Interpolation>\r\n) {\r\n  const rules = css(strings, ...interpolations);\r\n  const styledComponentId = `sc-global-${generateComponentId(JSON.stringify(rules))}`;\r\n  const globalStyle = new GlobalStyle(rules, styledComponentId);\r\n\r\n  if (process.env.NODE_ENV !== 'production') {\r\n    checkDynamicCreation(styledComponentId);\r\n  }\r\n\r\n  function GlobalStyleComponent(props: GlobalStyleComponentPropsType) {\r\n    const styleSheet = useStyleSheet();\r\n    const stylis = useStylis();\r\n    const theme = useContext(ThemeContext);\r\n    const instanceRef = useRef(null);\r\n\r\n    if (instanceRef.current === null) {\r\n      instanceRef.current = styleSheet.allocateGSInstance(styledComponentId);\r\n    }\r\n\r\n    const instance = instanceRef.current;\r\n\r\n    if (process.env.NODE_ENV !== 'production' && React.Children.count(props.children)) {\r\n      // eslint-disable-next-line no-console\r\n      console.warn(\r\n        `The global style component ${styledComponentId} was given child JSX. createGlobalStyle does not render children.`\r\n      );\r\n    }\r\n\r\n    if (\r\n      process.env.NODE_ENV !== 'production' &&\r\n      rules.some(rule => typeof rule === 'string' && rule.indexOf('@import') !== -1)\r\n    ) {\r\n      console.warn(\r\n        `Please do not use @import CSS syntax in createGlobalStyle at this time, as the CSSOM APIs we use in production do not handle it well. Instead, we recommend using a library such as react-helmet to inject a typical <link> meta tag to the stylesheet, or simply embedding it manually in your index.html <head> section for a simpler app.`\r\n      );\r\n    }\r\n\r\n    if (globalStyle.isStatic) {\r\n      globalStyle.renderStyles(instance, STATIC_EXECUTION_CONTEXT, styleSheet, stylis);\r\n    } else {\r\n      const context = {\r\n        ...props,\r\n        theme: determineTheme(props, theme, GlobalStyleComponent.defaultProps),\r\n      };\r\n\r\n      globalStyle.renderStyles(instance, context, styleSheet, stylis);\r\n    }\r\n\r\n    useEffect(() => () => globalStyle.removeStyles(instance, styleSheet), EMPTY_ARRAY);\r\n\r\n    return null;\r\n  }\r\n\r\n  // $FlowFixMe\r\n  return React.memo(GlobalStyleComponent);\r\n}\r\n","// @flow\r\n/* eslint-disable no-underscore-dangle */\r\nimport React from 'react';\r\nimport { IS_BROWSER, SC_ATTR, SC_ATTR_VERSION, SC_VERSION } from '../constants';\r\nimport throwStyledError from '../utils/error';\r\nimport getNonce from '../utils/nonce';\r\nimport StyleSheet from '../sheet';\r\nimport StyleSheetManager from './StyleSheetManager';\r\n\r\ndeclare var __SERVER__: boolean;\r\n\r\nconst CLOSING_TAG_R = /^\\s*<\\/[a-z]/i;\r\n\r\nexport default class ServerStyleSheet {\r\n  isStreaming: boolean;\r\n\r\n  instance: StyleSheet;\r\n\r\n  sealed: boolean;\r\n\r\n  constructor() {\r\n    this.instance = new StyleSheet({ isServer: true });\r\n    this.sealed = false;\r\n  }\r\n\r\n  _emitSheetCSS = (): string => {\r\n    const css = this.instance.toString();\r\n    const nonce = getNonce();\r\n    const attrs = [nonce && `nonce=\"${nonce}\"`, `${SC_ATTR}=\"true\"`, `${SC_ATTR_VERSION}=\"${SC_VERSION}\"`];\r\n    const htmlAttr = attrs.filter(Boolean).join(' ');\r\n\r\n    return `<style ${htmlAttr}>${css}</style>`;\r\n  };\r\n\r\n  collectStyles(children: any) {\r\n    if (this.sealed) {\r\n      return throwStyledError(2);\r\n    }\r\n\r\n    return <StyleSheetManager sheet={this.instance}>{children}</StyleSheetManager>;\r\n  }\r\n\r\n  getStyleTags = (): string => {\r\n    if (this.sealed) {\r\n      return throwStyledError(2);\r\n    }\r\n\r\n    return this._emitSheetCSS();\r\n  };\r\n\r\n  getStyleElement = () => {\r\n    if (this.sealed) {\r\n      return throwStyledError(2);\r\n    }\r\n\r\n    const props = {\r\n      [SC_ATTR]: '',\r\n      [SC_ATTR_VERSION]: SC_VERSION,\r\n      dangerouslySetInnerHTML: {\r\n        __html: this.instance.toString(),\r\n      },\r\n    };\r\n\r\n    const nonce = getNonce();\r\n    if (nonce) {\r\n      (props: any).nonce = nonce;\r\n    }\r\n\r\n    // v4 returned an array for this fn, so we'll do the same for v5 for backward compat\r\n    return [<style {...props} key=\"sc-0-0\" />];\r\n  };\r\n\r\n  // eslint-disable-next-line consistent-return\r\n  interleaveWithNodeStream(input: any) {\r\n    if (!__SERVER__ || IS_BROWSER) {\r\n      return throwStyledError(3);\r\n    } else if (this.sealed) {\r\n      return throwStyledError(2);\r\n    }\r\n\r\n    if (__SERVER__) {\r\n      this.seal();\r\n\r\n      // eslint-disable-next-line global-require\r\n      const { Readable, Transform } = require('stream');\r\n\r\n      const readableStream: Readable = input;\r\n      const { instance: sheet, _emitSheetCSS } = this;\r\n\r\n      const transformer = new Transform({\r\n        transform: function appendStyleChunks(chunk, /* encoding */ _, callback) {\r\n          // Get the chunk and retrieve the sheet's CSS as an HTML chunk,\r\n          // then reset its rules so we get only new ones for the next chunk\r\n          const renderedHtml = chunk.toString();\r\n          const html = _emitSheetCSS();\r\n\r\n          sheet.clearTag();\r\n\r\n          // prepend style html to chunk, unless the start of the chunk is a\r\n          // closing tag in which case append right after that\r\n          if (CLOSING_TAG_R.test(renderedHtml)) {\r\n            const endOfClosingTag = renderedHtml.indexOf('>') + 1;\r\n            const before = renderedHtml.slice(0, endOfClosingTag);\r\n            const after = renderedHtml.slice(endOfClosingTag);\r\n\r\n            this.push(before + html + after);\r\n          } else {\r\n            this.push(html + renderedHtml);\r\n          }\r\n\r\n          callback();\r\n        },\r\n      });\r\n\r\n      readableStream.on('error', err => {\r\n        // forward the error to the transform stream\r\n        transformer.emit('error', err);\r\n      });\r\n\r\n      return readableStream.pipe(transformer);\r\n    }\r\n  }\r\n\r\n  seal = () => {\r\n    this.sealed = true;\r\n  };\r\n}\r\n","// @flow\r\n\r\n/* Import singletons */\r\nimport isStyledComponent from './utils/isStyledComponent';\r\nimport css from './constructors/css';\r\nimport createGlobalStyle from './constructors/createGlobalStyle';\r\nimport keyframes from './constructors/keyframes';\r\nimport ServerStyleSheet from './models/ServerStyleSheet';\r\n\r\nimport StyleSheetManager, {\r\n  StyleSheetContext,\r\n  StyleSheetConsumer,\r\n} from './models/StyleSheetManager';\r\n\r\n/* Import components */\r\nimport ThemeProvider, { ThemeContext, ThemeConsumer } from './models/ThemeProvider';\r\n\r\n/* Import Higher Order Components */\r\nimport withTheme from './hoc/withTheme';\r\n\r\n/* Import hooks */\r\nimport useTheme from './hooks/useTheme';\r\n\r\nimport Realm from './models/Realm';\r\n\r\n/* Define bundle version for export */\r\ndeclare var __VERSION__: string;\r\nconst version = __VERSION__;\r\n\r\n/* Warning if you've imported this file on React Native */\r\nif (\r\n  process.env.NODE_ENV !== 'production' &&\r\n  typeof navigator !== 'undefined' &&\r\n  navigator.product === 'ReactNative'\r\n) {\r\n  // eslint-disable-next-line no-console\r\n  console.warn(\r\n    \"It looks like you've imported 'styled-components' on React Native.\\n\" +\r\n      \"Perhaps you're looking to import 'styled-components/native'?\\n\" +\r\n      'Read more about this at https://www.styled-components.com/docs/basics#react-native'\r\n  );\r\n}\r\n\r\n/* Warning if there are several instances of styled-components */\r\nif (\r\n  process.env.NODE_ENV !== 'production' &&\r\n  process.env.NODE_ENV !== 'test' &&\r\n  typeof window !== 'undefined'\r\n) {\r\n  window['__styled-components-init__'] = window['__styled-components-init__'] || 0;\r\n\r\n  if (window['__styled-components-init__'] === 1) {\r\n    // eslint-disable-next-line no-console\r\n    console.warn(\r\n      \"It looks like there are several instances of 'styled-components' initialized in this application. \" +\r\n        'This may cause dynamic styles not rendering properly, errors happening during rehydration process, ' +\r\n        'missing theme prop, and makes your application bigger without a good reason.\\n\\n' +\r\n        'See https://s-c.sh/2BAXzed for more info.'\r\n    );\r\n  }\r\n\r\n  window['__styled-components-init__'] += 1;\r\n}\r\n\r\n/* Export everything */\r\nexport * from './secretInternals';\r\nexport {\r\n  createGlobalStyle,\r\n  css,\r\n  isStyledComponent,\r\n  keyframes,\r\n  ServerStyleSheet,\r\n  StyleSheetConsumer,\r\n  StyleSheetContext,\r\n  StyleSheetManager,\r\n  ThemeConsumer,\r\n  ThemeContext,\r\n  ThemeProvider,\r\n  useTheme,\r\n  version,\r\n  withTheme,\r\n  Realm\r\n};\r\n","// @flow\n\nimport flatten from '../utils/flatten';\nimport { hash, phash } from '../utils/hash';\nimport generateName from '../utils/generateAlphabeticName';\nimport isStaticRules from '../utils/isStaticRules';\nimport StyleSheet from '../sheet';\n\nimport type {RealmScope, RuleSet, Stringifier} from '../types';\n\n/*\n ComponentStyle is all the CSS-specific stuff, not\n the React-specific stuff.\n */\nexport default class ComponentStyle {\n  baseHash: number;\n\n  componentId: string;\n\n  isStatic: boolean;\n\n  rules: RuleSet;\n\n  realmRules: Map<RealmScope, RuleSet>;\n\n  staticRulesId: string;\n\n  name: string;\n\n  constructor(rules: RuleSet, componentId: string) {\n    this.rules = rules;\n    this.staticRulesId = '';\n    this.isStatic = process.env.NODE_ENV === 'production' && isStaticRules(rules);\n    this.componentId = componentId;\n    this.baseHash = hash(componentId);\n\n    // NOTE: This registers the componentId, which ensures a consistent order\n    // for this component's styles compared to others\n    StyleSheet.registerId(componentId);\n  }\n\n  produceDynamicCssRules(executionContext: Object, styleSheet: StyleSheet, stylis: Stringifier, rules: RuleSet, buildHash: boolean = false, baseHash: number = 0) {\n    const { length } = rules;\n    let dynamicHash = buildHash ? phash(baseHash, stylis.hash) : 0;\n    let css = '';\n\n    for (let i = 0; i < length; i++) {\n      const partRule = rules[i];\n      if (typeof partRule === 'string') {\n        css += partRule;\n\n        if (process.env.NODE_ENV !== 'production' && buildHash) dynamicHash = phash(dynamicHash, partRule + i);\n      } else {\n        const partChunk = flatten(partRule, executionContext, styleSheet);\n        const partString = Array.isArray(partChunk) ? partChunk.join('') : partChunk;\n        if (buildHash) dynamicHash = phash(dynamicHash, partString + i);\n        css += partString;\n      }\n    }\n\n    return [css, dynamicHash];\n  }\n\n  /*\n   * Flattens a rule set into valid CSS\n   * Hashes it, wraps the whole chunk in a .hash1234 {}\n   * Returns the hash to be injected on render()\n   * */\n  generateAndInjectStyles(executionContext: Object, styleSheet: StyleSheet, stylis: Stringifier) {\n    const { componentId } = this;\n\n    // force dynamic classnames if user-supplied stylis plugins are in use\n    if (this.isStatic && !stylis.hash) {\n      if (this.staticRulesId && styleSheet.hasNameForId(componentId, this.staticRulesId)) {\n        return this.staticRulesId;\n      }\n\n      const cssStatic = flatten(this.rules, executionContext, styleSheet).join('');\n      const name = generateName(phash(this.baseHash, cssStatic.length) >>> 0);\n\n      if (!styleSheet.hasNameForId(componentId, name)) {\n        const cssStaticFormatted = stylis(cssStatic, `.${name}`, undefined, componentId);\n\n        styleSheet.insertRules(componentId, name, cssStaticFormatted);\n      }\n\n      this.staticRulesId = name;\n\n      return name;\n    } else {\n      const [css, dynamicHash] = this.produceDynamicCssRules(executionContext, styleSheet, stylis, this.rules, true, this.baseHash);\n\n      const name = generateName(dynamicHash >>> 0);\n\n      if (!styleSheet.hasNameForId(componentId, name)) {\n        const cssFormatted = stylis(css, `.${name}`, undefined, componentId);\n\n        styleSheet.insertRules(componentId, name, cssFormatted);\n      }\n\n      if (this.realmRules) {\n        this.realmRules.forEach((rules, realm) => {\n          const realmScopeName = `${realm}_${name}`;\n          if (!styleSheet.hasNameForId(componentId, realmScopeName)) {\n            const [realmCss] = this.produceDynamicCssRules(executionContext, styleSheet, stylis, rules);\n            const cssFormatted = stylis(realmCss, `.${realm} .${name}`, undefined, componentId);\n\n            styleSheet.insertRules(componentId, realmScopeName, cssFormatted);\n          }\n        });\n      }\n\n      return name;\n    }\n  }\n\n  addRealmRuleSet(realm: RealmScope, rules: RuleSet) {\n    if (!this.realmRules) {\n      this.realmRules = new Map();\n    }\n\n    this.realmRules.set(realm, rules);\n  }\n}\n","// @flow\r\nimport validAttr from '@emotion/is-prop-valid';\r\nimport React, {\r\n  createElement,\r\n  useContext,\r\n  useDebugValue,\r\n  type AbstractComponent,\r\n  type Ref,\r\n} from 'react';\r\nimport hoist from 'hoist-non-react-statics';\r\nimport merge from '../utils/mixinDeep';\r\nimport ComponentStyle from './ComponentStyle';\r\nimport createWarnTooManyClasses from '../utils/createWarnTooManyClasses';\r\nimport { checkDynamicCreation } from '../utils/checkDynamicCreation';\r\nimport determineTheme from '../utils/determineTheme';\r\nimport escape from '../utils/escape';\r\nimport generateDisplayName from '../utils/generateDisplayName';\r\nimport getComponentName from '../utils/getComponentName';\r\nimport generateComponentId from '../utils/generateComponentId';\r\nimport isFunction from '../utils/isFunction';\r\nimport isStyledComponent from '../utils/isStyledComponent';\r\nimport isTag from '../utils/isTag';\r\nimport joinStrings from '../utils/joinStrings';\r\nimport { ThemeContext } from './ThemeProvider';\r\nimport { useStyleSheet, useStylis } from './StyleSheetManager';\r\nimport { EMPTY_ARRAY, EMPTY_OBJECT } from '../utils/empties';\r\n\r\nimport type {Attrs, RealmScope, RuleSet, Target} from '../types';\r\n\r\n/* global $Call */\r\n\r\nconst identifiers = {};\r\n\r\n/* We depend on components having unique IDs */\r\nfunction generateId(displayName: string, parentComponentId: string) {\r\n  const name = typeof displayName !== 'string' ? 'sc' : escape(displayName);\r\n  // Ensure that no displayName can lead to duplicate componentIds\r\n  identifiers[name] = (identifiers[name] || 0) + 1;\r\n\r\n  const componentId = `${name}-${generateComponentId(name + identifiers[name])}`;\r\n  return parentComponentId ? `${parentComponentId}-${componentId}` : componentId;\r\n}\r\n\r\nfunction useResolvedAttrs<Config>(theme: any = EMPTY_OBJECT, props: Config, attrs: Attrs) {\r\n  // NOTE: can't memoize this\r\n  // returns [context, resolvedAttrs]\r\n  // where resolvedAttrs is only the things injected by the attrs themselves\r\n  const context = { ...props, theme };\r\n  const resolvedAttrs = {};\r\n\r\n  attrs.forEach(attrDef => {\r\n    let resolvedAttrDef = attrDef;\r\n    let key;\r\n\r\n    if (isFunction(resolvedAttrDef)) {\r\n      resolvedAttrDef = resolvedAttrDef(context);\r\n    }\r\n\r\n    /* eslint-disable guard-for-in */\r\n    for (key in resolvedAttrDef) {\r\n      context[key] = resolvedAttrs[key] =\r\n        key === 'className'\r\n          ? joinStrings(resolvedAttrs[key], resolvedAttrDef[key])\r\n          : resolvedAttrDef[key];\r\n    }\r\n    /* eslint-enable guard-for-in */\r\n  });\r\n\r\n  return [context, resolvedAttrs];\r\n}\r\n\r\ninterface StyledComponentWrapperProperties {\r\n  attrs: Attrs;\r\n  componentStyle: ComponentStyle;\r\n  displayName: string;\r\n  foldedComponentIds: Array<string>;\r\n  target: Target;\r\n  shouldForwardProp: ?(prop: string) => boolean;\r\n  styledComponentId: string;\r\n  warnTooManyClasses: $Call<typeof createWarnTooManyClasses, string, string>;\r\n}\r\n\r\ntype StyledComponentWrapper<Config, Instance> = AbstractComponent<Config, Instance> &\r\n  StyledComponentWrapperProperties;\r\n\r\nfunction useInjectedStyle<T>(\r\n  componentStyle: ComponentStyle,\r\n  hasAttrs: boolean,\r\n  resolvedAttrs: T,\r\n  warnTooManyClasses?: $Call<typeof createWarnTooManyClasses, string, string>\r\n) {\r\n  const styleSheet = useStyleSheet();\r\n  const stylis = useStylis();\r\n\r\n  // statically styled-components don't need to build an execution context object,\r\n  // and shouldn't be increasing the number of class names\r\n  const isStatic = componentStyle.isStatic && !hasAttrs;\r\n\r\n  const className = isStatic\r\n    ? componentStyle.generateAndInjectStyles(EMPTY_OBJECT, styleSheet, stylis)\r\n    : componentStyle.generateAndInjectStyles(resolvedAttrs, styleSheet, stylis);\r\n\r\n  useDebugValue(className);\r\n\r\n  if (process.env.NODE_ENV !== 'production' && !isStatic && warnTooManyClasses) {\r\n    warnTooManyClasses(className);\r\n  }\r\n\r\n  return className;\r\n}\r\n\r\nfunction useStyledComponentImpl<Config: {}, Instance>(\r\n  forwardedComponent: StyledComponentWrapper<Config, Instance>,\r\n  props: Object,\r\n  forwardedRef: Ref<any>\r\n) {\r\n  const {\r\n    attrs: componentAttrs,\r\n    componentStyle,\r\n    // $FlowFixMe\r\n    defaultProps,\r\n    foldedComponentIds,\r\n    shouldForwardProp,\r\n    styledComponentId,\r\n    target,\r\n  } = forwardedComponent;\r\n\r\n  useDebugValue(styledComponentId);\r\n\r\n  // NOTE: the non-hooks version only subscribes to this when !componentStyle.isStatic,\r\n  // but that'd be against the rules-of-hooks. We could be naughty and do it anyway as it\r\n  // should be an immutable value, but behave for now.\r\n  const theme = determineTheme(props, useContext(ThemeContext), defaultProps);\r\n\r\n  const [context, attrs] = useResolvedAttrs(theme || EMPTY_OBJECT, props, componentAttrs);\r\n\r\n  const generatedClassName = useInjectedStyle(\r\n    componentStyle,\r\n    componentAttrs.length > 0,\r\n    context,\r\n    process.env.NODE_ENV !== 'production' ? forwardedComponent.warnTooManyClasses : undefined\r\n  );\r\n\r\n  const refToForward = forwardedRef;\r\n\r\n  const elementToBeCreated: Target = attrs.as || props.as || target;\r\n\r\n  const isTargetTag = isTag(elementToBeCreated);\r\n  const computedProps = attrs !== props ? { ...props, ...attrs } : props;\r\n  const shouldFilterProps = 'as' in computedProps || 'forwardedAs' in computedProps;\r\n  const propFilterFn = shouldForwardProp || (isTargetTag && validAttr);\r\n  const propsForElement = propFilterFn || shouldFilterProps ? {} : { ...computedProps };\r\n\r\n  if (shouldFilterProps || propFilterFn) {\r\n    // eslint-disable-next-line guard-for-in\r\n    for (const key in computedProps) {\r\n      if (key === 'forwardedAs') {\r\n        propsForElement.as = computedProps[key];\r\n      } else if (key !== 'as' && (!propFilterFn || propFilterFn(key))) {\r\n        // Don't pass through non HTML tags through to HTML elements\r\n        propsForElement[key] = computedProps[key];\r\n      }\r\n    }\r\n  }\r\n\r\n  if (props.style && attrs.style !== props.style) {\r\n    propsForElement.style = { ...props.style, ...attrs.style };\r\n  }\r\n\r\n  propsForElement.className = Array.prototype\r\n    .concat(\r\n      foldedComponentIds,\r\n      styledComponentId,\r\n      generatedClassName !== styledComponentId ? generatedClassName : null,\r\n      props.className,\r\n      attrs.className\r\n    )\r\n    .filter(Boolean)\r\n    .join(' ');\r\n\r\n  propsForElement.ref = refToForward;\r\n\r\n  return createElement(elementToBeCreated, propsForElement);\r\n}\r\n\r\nfunction addRealmStyleToComponent(\r\n  target: StyledComponentWrapper<*, *>,\r\n  realm: RealmScope,\r\n  rules: RuleSet,\r\n) {\r\n  target.componentStyle.addRealmRuleSet(realm, rules);\r\n}\r\n\r\nexport default function createStyledComponent(\r\n  target: Target | StyledComponentWrapper<*, *>,\r\n  options: Object,\r\n  rules: RuleSet,\r\n  realm: ?RealmScope\r\n) {\r\n  const isTargetStyledComp = isStyledComponent(target);\r\n  const isCompositeComponent = !isTag(target);\r\n\r\n  if (isTargetStyledComp && realm) {\r\n    // $FlowFixMe\r\n    addRealmStyleToComponent(target, realm, rules);\r\n\r\n    return target;\r\n  }\r\n\r\n  const {\r\n    displayName = generateDisplayName(target),\r\n    componentId = generateId(options.displayName, options.parentComponentId),\r\n    attrs = EMPTY_ARRAY,\r\n  } = options;\r\n\r\n  const styledComponentId =\r\n    options.displayName && options.componentId\r\n      ? `${escape(options.displayName)}-${options.componentId}`\r\n      : options.componentId || componentId;\r\n\r\n  // fold the underlying StyledComponent attrs up (implicit extend)\r\n  const finalAttrs =\r\n    // $FlowFixMe\r\n    isTargetStyledComp && target.attrs\r\n      ? Array.prototype.concat(target.attrs, attrs).filter(Boolean)\r\n      : attrs;\r\n\r\n  // eslint-disable-next-line prefer-destructuring\r\n  let shouldForwardProp = options.shouldForwardProp;\r\n  // $FlowFixMe\r\n  if (isTargetStyledComp && target.shouldForwardProp) {\r\n    if (shouldForwardProp) {\r\n      // compose nested shouldForwardProp calls\r\n      // $FlowFixMe\r\n      shouldForwardProp = prop => target.shouldForwardProp(prop) && options.shouldForwardProp(prop);\r\n    } else {\r\n      // eslint-disable-next-line prefer-destructuring\r\n      shouldForwardProp = target.shouldForwardProp\r\n    }\r\n  }\r\n\r\n  const componentStyle = new ComponentStyle(\r\n    isTargetStyledComp\r\n      ? // fold the underlying StyledComponent rules up (implicit extend)\r\n        // $FlowFixMe\r\n      target.componentStyle.rules.concat(rules)\r\n      : rules,\r\n    styledComponentId\r\n  );\r\n\r\n  /**\r\n   * forwardRef creates a new interim component, which we'll take advantage of\r\n   * instead of extending ParentComponent to create _another_ interim class\r\n   */\r\n  let WrappedStyledComponent;\r\n\r\n  // eslint-disable-next-line react-hooks/rules-of-hooks\r\n  const forwardRef = (props, ref) => useStyledComponentImpl(WrappedStyledComponent, props, ref);\r\n\r\n  forwardRef.displayName = displayName;\r\n\r\n  // $FlowFixMe this is a forced cast to merge it StyledComponentWrapperProperties\r\n  WrappedStyledComponent = (React.forwardRef(forwardRef): StyledComponentWrapper<*, *>);\r\n\r\n  WrappedStyledComponent.attrs = finalAttrs;\r\n  WrappedStyledComponent.componentStyle = componentStyle;\r\n  WrappedStyledComponent.displayName = displayName;\r\n  WrappedStyledComponent.shouldForwardProp = shouldForwardProp;\r\n\r\n  // this static is used to preserve the cascade of static classes for component selector\r\n  // purposes; this is especially important with usage of the css prop\r\n  WrappedStyledComponent.foldedComponentIds = isTargetStyledComp\r\n    ? // $FlowFixMe\r\n    Array.prototype.concat(target.foldedComponentIds, target.styledComponentId)\r\n    : EMPTY_ARRAY;\r\n\r\n  WrappedStyledComponent.styledComponentId = styledComponentId;\r\n\r\n  // fold the underlying StyledComponent target up since we folded the styles\r\n  WrappedStyledComponent.target = isTargetStyledComp\r\n    ? // $FlowFixMe\r\n    target.target\r\n    : target;\r\n\r\n  // $FlowFixMe\r\n  WrappedStyledComponent.withComponent = function withComponent(tag: Target) {\r\n    const { componentId: previousComponentId, ...optionsToCopy } = options;\r\n\r\n    const newComponentId =\r\n      previousComponentId &&\r\n      `${previousComponentId}-${isTag(tag) ? tag : escape(getComponentName(tag))}`;\r\n\r\n    const newOptions = {\r\n      ...optionsToCopy,\r\n      attrs: finalAttrs,\r\n      componentId: newComponentId,\r\n    };\r\n\r\n    return createStyledComponent(tag, newOptions, rules);\r\n  };\r\n\r\n  // $FlowFixMe\r\n  Object.defineProperty(WrappedStyledComponent, 'defaultProps', {\r\n    get() {\r\n      return this._foldedDefaultProps;\r\n    },\r\n\r\n    set(obj) {\r\n      // $FlowFixMe\r\n      this._foldedDefaultProps = isTargetStyledComp ? merge({}, target.defaultProps, obj) : obj;\r\n    },\r\n  });\r\n\r\n  if (process.env.NODE_ENV !== 'production') {\r\n    checkDynamicCreation(displayName, styledComponentId);\r\n\r\n    WrappedStyledComponent.warnTooManyClasses = createWarnTooManyClasses(\r\n      displayName,\r\n      styledComponentId\r\n    );\r\n  }\r\n\r\n  // $FlowFixMe\r\n  WrappedStyledComponent.toString = () => `.${WrappedStyledComponent.styledComponentId}`;\r\n\r\n  if (isCompositeComponent) {\r\n    hoist(WrappedStyledComponent, (target: any), {\r\n      // all SC-specific things should not be hoisted\r\n      attrs: true,\r\n      componentStyle: true,\r\n      displayName: true,\r\n      foldedComponentIds: true,\r\n      shouldForwardProp: true,\r\n      self: true,\r\n      styledComponentId: true,\r\n      target: true,\r\n      withComponent: true,\r\n    });\r\n  }\r\n\r\n  return WrappedStyledComponent;\r\n}\r\n"],"names":["nodes","insertRule","names","id","stylisPlugins","flatten","React","isTargetStyledComp"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAGgC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ECiB9B,0BAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;6BAyC8B;;;;;;;;;;;;;;;;;;;;;;;;;;;oBAyBNA;;;;;;;;;;;;;;;;;;;;YAgBxBC,aAAA,yBAAA,MAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ECrFA,gCAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;qBCXiB;qBACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ECmBjB;;;;;;;;;;;;;;;;WAgBQC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;0BA+B8BC;;;;;;;;;;;;;;;;;;;;uBAkBVA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;yCC5DiBC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;8CC1BM;;;;;;;;;;;;;;;;;;ECKnD,4BAAA,aAAA;;;;;;;;;oBAYkBC;;UAEVF;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;mBCNS;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ECFjB;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;gBAiDUG,wDAAA;;EAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ECvCoB,qBAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ECL9B,+BAAA,aAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;QC6KMC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;"}