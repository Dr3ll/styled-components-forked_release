{"version":3,"file":"styled-components.min.js","sources":["../src/sheet/Tag.js","../src/sheet/Sheet.js","../src/models/StyleSheetManager.js","../src/utils/isStaticRules.js","../src/models/GlobalStyle.js","../src/models/ServerStyleSheet.js","../src/models/StyledComponent.js"],"sourcesContent":["// @flow\r\n/* eslint-disable no-use-before-define */\r\n\r\nimport { makeStyleTag, getSheet } from './dom';\r\nimport type { SheetOptions, Tag } from './types';\r\n\r\n/** Create a CSSStyleSheet-like tag depending on the environment */\r\nexport const makeTag = ({ isServer, useCSSOMInjection, target }: SheetOptions): Tag => {\r\n  if (isServer) {\r\n    return new VirtualTag(target);\r\n  } else if (useCSSOMInjection) {\r\n    return new CSSOMTag(target);\r\n  } else {\r\n    return new TextTag(target);\r\n  }\r\n};\r\n\r\nexport class CSSOMTag implements Tag {\r\n  element: HTMLStyleElement;\r\n\r\n  sheet: CSSStyleSheet;\r\n\r\n  length: number;\r\n\r\n  constructor(target?: HTMLElement) {\r\n    const element = (this.element = makeStyleTag(target));\r\n\r\n    // Avoid Edge bug where empty style elements don't create sheets\r\n    element.appendChild(document.createTextNode(''));\r\n\r\n    this.sheet = getSheet(element);\r\n    this.length = 0;\r\n  }\r\n\r\n  insertRule(index: number, rule: string): boolean {\r\n    try {\r\n      this.sheet.insertRule(rule, index);\r\n      this.length++;\r\n      return true;\r\n    } catch (_error) {\r\n      return false;\r\n    }\r\n  }\r\n\r\n  deleteRule(index: number): void {\r\n    this.sheet.deleteRule(index);\r\n    this.length--;\r\n  }\r\n\r\n  getRule(index: number): string {\r\n    const rule = this.sheet.cssRules[index];\r\n    // Avoid IE11 quirk where cssText is inaccessible on some invalid rules\r\n    if (rule !== undefined && typeof rule.cssText === 'string') {\r\n      return rule.cssText;\r\n    } else {\r\n      return '';\r\n    }\r\n  }\r\n}\r\n\r\n/** A Tag that emulates the CSSStyleSheet API but uses text nodes */\r\nexport class TextTag implements Tag {\r\n  element: HTMLStyleElement;\r\n\r\n  nodes: NodeList<Node>;\r\n\r\n  length: number;\r\n\r\n  constructor(target?: HTMLElement) {\r\n    const element = (this.element = makeStyleTag(target));\r\n    this.nodes = element.childNodes;\r\n    this.length = 0;\r\n  }\r\n\r\n  insertRule(index: number, rule: string): boolean {\r\n    if (index <= this.length && index >= 0) {\r\n      const node = document.createTextNode(rule);\r\n      const refNode = this.nodes[index];\r\n      this.element.insertBefore(node, refNode || null);\r\n      this.length++;\r\n      return true;\r\n    } else {\r\n      return false;\r\n    }\r\n  }\r\n\r\n  deleteRule(index: number): void {\r\n    this.element.removeChild(this.nodes[index]);\r\n    this.length--;\r\n  }\r\n\r\n  getRule(index: number): string {\r\n    if (index < this.length) {\r\n      return this.nodes[index].textContent;\r\n    } else {\r\n      return '';\r\n    }\r\n  }\r\n}\r\n\r\n/** A completely virtual (server-side) Tag that doesn't manipulate the DOM */\r\nexport class VirtualTag implements Tag {\r\n  rules: string[];\r\n\r\n  length: number;\r\n\r\n  constructor(_target?: HTMLElement) {\r\n    this.rules = [];\r\n    this.length = 0;\r\n  }\r\n\r\n  insertRule(index: number, rule: string): boolean {\r\n    if (index <= this.length) {\r\n      this.rules.splice(index, 0, rule);\r\n      this.length++;\r\n      return true;\r\n    } else {\r\n      return false;\r\n    }\r\n  }\r\n\r\n  deleteRule(index: number): void {\r\n    this.rules.splice(index, 1);\r\n    this.length--;\r\n  }\r\n\r\n  getRule(index: number): string {\r\n    if (index < this.length) {\r\n      return this.rules[index];\r\n    } else {\r\n      return '';\r\n    }\r\n  }\r\n}\r\n","// @flow\r\nimport { DISABLE_SPEEDY, IS_BROWSER } from '../constants';\r\nimport type { GroupedTag, Sheet, SheetOptions } from './types';\r\nimport { makeTag } from './Tag';\r\nimport { makeGroupedTag } from './GroupedTag';\r\nimport { getGroupForId } from './GroupIDAllocator';\r\nimport { outputSheet, rehydrateSheet } from './Rehydration';\r\n\r\nlet SHOULD_REHYDRATE = IS_BROWSER;\r\n\r\ntype SheetConstructorArgs = {\r\n  isServer?: boolean,\r\n  useCSSOMInjection?: boolean,\r\n  target?: HTMLElement,\r\n};\r\n\r\ntype GlobalStylesAllocationMap = { [key: string]: number };\r\ntype NamesAllocationMap = Map<string, Set<string>>;\r\n\r\nconst defaultOptions = {\r\n  isServer: !IS_BROWSER,\r\n  useCSSOMInjection: !DISABLE_SPEEDY,\r\n};\r\n\r\n/** Contains the main stylesheet logic for stringification and caching */\r\nexport default class StyleSheet implements Sheet {\r\n  gs: GlobalStylesAllocationMap;\r\n\r\n  names: NamesAllocationMap;\r\n\r\n  options: SheetOptions;\r\n\r\n  tag: void | GroupedTag;\r\n\r\n  /** Register a group ID to give it an index */\r\n  static registerId(id: string): number {\r\n    return getGroupForId(id);\r\n  }\r\n\r\n  constructor(\r\n    options: SheetConstructorArgs = defaultOptions,\r\n    globalStyles?: GlobalStylesAllocationMap = {},\r\n    names?: NamesAllocationMap\r\n  ) {\r\n    this.options = {\r\n      ...defaultOptions,\r\n      ...options,\r\n    };\r\n\r\n    this.gs = globalStyles;\r\n    this.names = new Map(names);\r\n\r\n    // We rehydrate only once and use the sheet that is created first\r\n    if (!this.options.isServer && IS_BROWSER && SHOULD_REHYDRATE) {\r\n      SHOULD_REHYDRATE = false;\r\n      rehydrateSheet(this);\r\n    }\r\n  }\r\n\r\n  reconstructWithOptions(options: SheetConstructorArgs) {\r\n    return new StyleSheet({ ...this.options, ...options }, this.gs, this.names);\r\n  }\r\n\r\n  allocateGSInstance(id: string) {\r\n    return (this.gs[id] = (this.gs[id] || 0) + 1);\r\n  }\r\n\r\n  /** Lazily initialises a GroupedTag for when it's actually needed */\r\n  getTag(): GroupedTag {\r\n    return this.tag || (this.tag = makeGroupedTag(makeTag(this.options)));\r\n  }\r\n\r\n  /** Check whether a name is known for caching */\r\n  hasNameForId(id: string, name: string): boolean {\r\n    return this.names.has(id) && (this.names.get(id): any).has(name);\r\n  }\r\n\r\n  /** Mark a group's name as known for caching */\r\n  registerName(id: string, name: string) {\r\n    getGroupForId(id);\r\n\r\n    if (!this.names.has(id)) {\r\n      const groupNames = new Set();\r\n      groupNames.add(name);\r\n      this.names.set(id, groupNames);\r\n    } else {\r\n      (this.names.get(id): any).add(name);\r\n    }\r\n  }\r\n\r\n  /** Insert new rules which also marks the name as known */\r\n  insertRules(id: string, name: string, rules: string[]) {\r\n    this.registerName(id, name);\r\n    this.getTag().insertRules(getGroupForId(id), rules);\r\n  }\r\n\r\n  /** Clears all cached names for a given group ID */\r\n  clearNames(id: string) {\r\n    if (this.names.has(id)) {\r\n      (this.names.get(id): any).clear();\r\n    }\r\n  }\r\n\r\n  /** Clears all rules for a given group ID */\r\n  clearRules(id: string) {\r\n    this.getTag().clearGroup(getGroupForId(id));\r\n    this.clearNames(id);\r\n  }\r\n\r\n  /** Clears the entire tag which deletes all rules but not its names */\r\n  clearTag() {\r\n    // NOTE: This does not clear the names, since it's only used during SSR\r\n    // so that we can continuously output only new rules\r\n    this.tag = undefined;\r\n  }\r\n\r\n  /** Outputs the current sheet as a CSS string with markers for SSR */\r\n  toString(): string {\r\n    return outputSheet(this);\r\n  }\r\n}\r\n","// @flow\r\nimport React, { useContext, useEffect, useMemo, useState, type Node, type Context } from 'react';\r\nimport shallowequal from 'shallowequal';\r\nimport StyleSheet from '../sheet';\r\nimport createStylisInstance, { type Stringifier } from '../utils/stylis';\r\n\r\ntype Props = {\r\n  children?: Node,\r\n  disableCSSOMInjection?: boolean,\r\n  disableVendorPrefixes?: boolean,\r\n  sheet?: StyleSheet,\r\n  stylisPlugins?: Array<Function>,\r\n  target?: HTMLElement,\r\n};\r\n\r\nexport const StyleSheetContext: Context<StyleSheet | void> = React.createContext();\r\nexport const StyleSheetConsumer = StyleSheetContext.Consumer;\r\nexport const StylisContext: Context<Stringifier | void> = React.createContext();\r\nexport const StylisConsumer = StylisContext.Consumer;\r\n\r\nexport const masterSheet: StyleSheet = new StyleSheet();\r\nexport const masterStylis: Stringifier = createStylisInstance();\r\n\r\nexport function useStyleSheet(): StyleSheet {\r\n  return useContext(StyleSheetContext) || masterSheet;\r\n}\r\n\r\nexport function useStylis(): Stringifier {\r\n  return useContext(StylisContext) || masterStylis;\r\n}\r\n\r\nexport default function StyleSheetManager(props: Props) {\r\n  const [plugins, setPlugins] = useState(props.stylisPlugins);\r\n  const contextStyleSheet = useStyleSheet();\r\n\r\n  const styleSheet = useMemo(() => {\r\n    let sheet = contextStyleSheet;\r\n\r\n    if (props.sheet) {\r\n      // eslint-disable-next-line prefer-destructuring\r\n      sheet = props.sheet;\r\n    } else if (props.target) {\r\n      sheet = sheet.reconstructWithOptions({ target: props.target });\r\n    }\r\n\r\n    if (props.disableCSSOMInjection) {\r\n      sheet = sheet.reconstructWithOptions({ useCSSOMInjection: false });\r\n    }\r\n\r\n    return sheet;\r\n  }, [props.disableCSSOMInjection, props.sheet, props.target]);\r\n\r\n  const stylis = useMemo(\r\n    () =>\r\n      createStylisInstance({\r\n        options: { prefix: !props.disableVendorPrefixes },\r\n        plugins,\r\n      }),\r\n    [props.disableVendorPrefixes, plugins]\r\n  );\r\n\r\n  useEffect(() => {\r\n    if (!shallowequal(plugins, props.stylisPlugins)) setPlugins(props.stylisPlugins);\r\n  }, [props.stylisPlugins]);\r\n\r\n  return (\r\n    <StyleSheetContext.Provider value={styleSheet}>\r\n      <StylisContext.Provider value={stylis}>\r\n        {process.env.NODE_ENV !== 'production'\r\n          ? React.Children.only(props.children)\r\n          : props.children}\r\n      </StylisContext.Provider>\r\n    </StyleSheetContext.Provider>\r\n  );\r\n}\r\n","// @flow\r\nimport isFunction from './isFunction';\r\nimport isStyledComponent from './isStyledComponent';\r\nimport type { RuleSet } from '../types';\r\n\r\nexport default function isStaticRules(rules: RuleSet): boolean {\r\n  for (let i = 0; i < rules.length; i += 1) {\r\n    const rule = rules[i];\r\n\r\n    if (isFunction(rule) && !isStyledComponent(rule)) {\r\n      // functions are allowed to be static if they're just being\r\n      // used to get the classname of a nested styled component\r\n      return false;\r\n    }\r\n  }\r\n\r\n  return true;\r\n}\r\n","// @flow\r\nimport flatten from '../utils/flatten';\r\nimport isStaticRules from '../utils/isStaticRules';\r\nimport StyleSheet from '../sheet';\r\n\r\nimport type { RuleSet, Stringifier } from '../types';\r\n\r\nexport default class GlobalStyle {\r\n  componentId: string;\r\n\r\n  isStatic: boolean;\r\n\r\n  rules: RuleSet;\r\n\r\n  constructor(rules: RuleSet, componentId: string) {\r\n    this.rules = rules;\r\n    this.componentId = componentId;\r\n    this.isStatic = isStaticRules(rules);\r\n  }\r\n\r\n  createStyles(\r\n    instance: number,\r\n    executionContext: Object,\r\n    styleSheet: StyleSheet,\r\n    stylis: Stringifier\r\n  ) {\r\n    const flatCSS = flatten(this.rules, executionContext, styleSheet);\r\n    const css = stylis(flatCSS.join(''), '');\r\n    const id = this.componentId + instance;\r\n\r\n    // NOTE: We use the id as a name as well, since these rules never change\r\n\r\n    styleSheet.insertRules(id, id, css);\r\n  }\r\n\r\n  removeStyles(instance: number, styleSheet: StyleSheet) {\r\n    styleSheet.clearRules(this.componentId + instance);\r\n  }\r\n\r\n  renderStyles(\r\n    instance: number,\r\n    executionContext: Object,\r\n    styleSheet: StyleSheet,\r\n    stylis: Stringifier\r\n  ) {\r\n    StyleSheet.registerId(this.componentId + instance);\r\n\r\n    // NOTE: Remove old styles, then inject the new ones\r\n    this.removeStyles(instance, styleSheet);\r\n    this.createStyles(instance, executionContext, styleSheet, stylis);\r\n  }\r\n}\r\n","// @flow\r\n/* eslint-disable no-underscore-dangle */\r\nimport React from 'react';\r\nimport { IS_BROWSER, SC_ATTR, SC_ATTR_VERSION, SC_VERSION } from '../constants';\r\nimport throwStyledError from '../utils/error';\r\nimport getNonce from '../utils/nonce';\r\nimport StyleSheet from '../sheet';\r\nimport StyleSheetManager from './StyleSheetManager';\r\n\r\ndeclare var __SERVER__: boolean;\r\n\r\nconst CLOSING_TAG_R = /^\\s*<\\/[a-z]/i;\r\n\r\nexport default class ServerStyleSheet {\r\n  isStreaming: boolean;\r\n\r\n  instance: StyleSheet;\r\n\r\n  sealed: boolean;\r\n\r\n  constructor() {\r\n    this.instance = new StyleSheet({ isServer: true });\r\n    this.sealed = false;\r\n  }\r\n\r\n  _emitSheetCSS = (): string => {\r\n    const css = this.instance.toString();\r\n    const nonce = getNonce();\r\n    const attrs = [nonce && `nonce=\"${nonce}\"`, `${SC_ATTR}=\"true\"`, `${SC_ATTR_VERSION}=\"${SC_VERSION}\"`];\r\n    const htmlAttr = attrs.filter(Boolean).join(' ');\r\n\r\n    return `<style ${htmlAttr}>${css}</style>`;\r\n  };\r\n\r\n  collectStyles(children: any) {\r\n    if (this.sealed) {\r\n      return throwStyledError(2);\r\n    }\r\n\r\n    return <StyleSheetManager sheet={this.instance}>{children}</StyleSheetManager>;\r\n  }\r\n\r\n  getStyleTags = (): string => {\r\n    if (this.sealed) {\r\n      return throwStyledError(2);\r\n    }\r\n\r\n    return this._emitSheetCSS();\r\n  };\r\n\r\n  getStyleElement = () => {\r\n    if (this.sealed) {\r\n      return throwStyledError(2);\r\n    }\r\n\r\n    const props = {\r\n      [SC_ATTR]: '',\r\n      [SC_ATTR_VERSION]: SC_VERSION,\r\n      dangerouslySetInnerHTML: {\r\n        __html: this.instance.toString(),\r\n      },\r\n    };\r\n\r\n    const nonce = getNonce();\r\n    if (nonce) {\r\n      (props: any).nonce = nonce;\r\n    }\r\n\r\n    // v4 returned an array for this fn, so we'll do the same for v5 for backward compat\r\n    return [<style {...props} key=\"sc-0-0\" />];\r\n  };\r\n\r\n  // eslint-disable-next-line consistent-return\r\n  interleaveWithNodeStream(input: any) {\r\n    if (!__SERVER__ || IS_BROWSER) {\r\n      return throwStyledError(3);\r\n    } else if (this.sealed) {\r\n      return throwStyledError(2);\r\n    }\r\n\r\n    if (__SERVER__) {\r\n      this.seal();\r\n\r\n      // eslint-disable-next-line global-require\r\n      const { Readable, Transform } = require('stream');\r\n\r\n      const readableStream: Readable = input;\r\n      const { instance: sheet, _emitSheetCSS } = this;\r\n\r\n      const transformer = new Transform({\r\n        transform: function appendStyleChunks(chunk, /* encoding */ _, callback) {\r\n          // Get the chunk and retrieve the sheet's CSS as an HTML chunk,\r\n          // then reset its rules so we get only new ones for the next chunk\r\n          const renderedHtml = chunk.toString();\r\n          const html = _emitSheetCSS();\r\n\r\n          sheet.clearTag();\r\n\r\n          // prepend style html to chunk, unless the start of the chunk is a\r\n          // closing tag in which case append right after that\r\n          if (CLOSING_TAG_R.test(renderedHtml)) {\r\n            const endOfClosingTag = renderedHtml.indexOf('>') + 1;\r\n            const before = renderedHtml.slice(0, endOfClosingTag);\r\n            const after = renderedHtml.slice(endOfClosingTag);\r\n\r\n            this.push(before + html + after);\r\n          } else {\r\n            this.push(html + renderedHtml);\r\n          }\r\n\r\n          callback();\r\n        },\r\n      });\r\n\r\n      readableStream.on('error', err => {\r\n        // forward the error to the transform stream\r\n        transformer.emit('error', err);\r\n      });\r\n\r\n      return readableStream.pipe(transformer);\r\n    }\r\n  }\r\n\r\n  seal = () => {\r\n    this.sealed = true;\r\n  };\r\n}\r\n","// @flow\r\nimport validAttr from '@emotion/is-prop-valid';\r\nimport React, {\r\n  createElement,\r\n  useContext,\r\n  useDebugValue,\r\n  type AbstractComponent,\r\n  type Ref,\r\n} from 'react';\r\nimport hoist from 'hoist-non-react-statics';\r\nimport merge from '../utils/mixinDeep';\r\nimport ComponentStyle from './ComponentStyle';\r\nimport createWarnTooManyClasses from '../utils/createWarnTooManyClasses';\r\nimport { checkDynamicCreation } from '../utils/checkDynamicCreation';\r\nimport determineTheme from '../utils/determineTheme';\r\nimport escape from '../utils/escape';\r\nimport generateDisplayName from '../utils/generateDisplayName';\r\nimport getComponentName from '../utils/getComponentName';\r\nimport generateComponentId from '../utils/generateComponentId';\r\nimport isFunction from '../utils/isFunction';\r\nimport isStyledComponent from '../utils/isStyledComponent';\r\nimport isTag from '../utils/isTag';\r\nimport joinStrings from '../utils/joinStrings';\r\nimport { ThemeContext } from './ThemeProvider';\r\nimport { useStyleSheet, useStylis } from './StyleSheetManager';\r\nimport { EMPTY_ARRAY, EMPTY_OBJECT } from '../utils/empties';\r\n\r\nimport type {Attrs, RealmScope, RuleSet, Target} from '../types';\r\n\r\n/* global $Call */\r\n\r\nconst identifiers = {};\r\n\r\n/* We depend on components having unique IDs */\r\nfunction generateId(displayName: string, parentComponentId: string) {\r\n  const name = typeof displayName !== 'string' ? 'sc' : escape(displayName);\r\n  // Ensure that no displayName can lead to duplicate componentIds\r\n  identifiers[name] = (identifiers[name] || 0) + 1;\r\n\r\n  const componentId = `${name}-${generateComponentId(name + identifiers[name])}`;\r\n  return parentComponentId ? `${parentComponentId}-${componentId}` : componentId;\r\n}\r\n\r\nfunction useResolvedAttrs<Config>(theme: any = EMPTY_OBJECT, props: Config, attrs: Attrs) {\r\n  // NOTE: can't memoize this\r\n  // returns [context, resolvedAttrs]\r\n  // where resolvedAttrs is only the things injected by the attrs themselves\r\n  const context = { ...props, theme };\r\n  const resolvedAttrs = {};\r\n\r\n  attrs.forEach(attrDef => {\r\n    let resolvedAttrDef = attrDef;\r\n    let key;\r\n\r\n    if (isFunction(resolvedAttrDef)) {\r\n      resolvedAttrDef = resolvedAttrDef(context);\r\n    }\r\n\r\n    /* eslint-disable guard-for-in */\r\n    for (key in resolvedAttrDef) {\r\n      context[key] = resolvedAttrs[key] =\r\n        key === 'className'\r\n          ? joinStrings(resolvedAttrs[key], resolvedAttrDef[key])\r\n          : resolvedAttrDef[key];\r\n    }\r\n    /* eslint-enable guard-for-in */\r\n  });\r\n\r\n  return [context, resolvedAttrs];\r\n}\r\n\r\ninterface StyledComponentWrapperProperties {\r\n  attrs: Attrs;\r\n  componentStyle: ComponentStyle;\r\n  displayName: string;\r\n  foldedComponentIds: Array<string>;\r\n  target: Target;\r\n  shouldForwardProp: ?(prop: string) => boolean;\r\n  styledComponentId: string;\r\n  warnTooManyClasses: $Call<typeof createWarnTooManyClasses, string, string>;\r\n}\r\n\r\ntype StyledComponentWrapper<Config, Instance> = AbstractComponent<Config, Instance> &\r\n  StyledComponentWrapperProperties;\r\n\r\nfunction useInjectedStyle<T>(\r\n  componentStyle: ComponentStyle,\r\n  hasAttrs: boolean,\r\n  resolvedAttrs: T,\r\n  warnTooManyClasses?: $Call<typeof createWarnTooManyClasses, string, string>\r\n) {\r\n  const styleSheet = useStyleSheet();\r\n  const stylis = useStylis();\r\n\r\n  // statically styled-components don't need to build an execution context object,\r\n  // and shouldn't be increasing the number of class names\r\n  const isStatic = componentStyle.isStatic && !hasAttrs;\r\n\r\n  const className = isStatic\r\n    ? componentStyle.generateAndInjectStyles(EMPTY_OBJECT, styleSheet, stylis)\r\n    : componentStyle.generateAndInjectStyles(resolvedAttrs, styleSheet, stylis);\r\n\r\n  useDebugValue(className);\r\n\r\n  if (process.env.NODE_ENV !== 'production' && !isStatic && warnTooManyClasses) {\r\n    warnTooManyClasses(className);\r\n  }\r\n\r\n  return className;\r\n}\r\n\r\nfunction useStyledComponentImpl<Config: {}, Instance>(\r\n  forwardedComponent: StyledComponentWrapper<Config, Instance>,\r\n  props: Object,\r\n  forwardedRef: Ref<any>\r\n) {\r\n  const {\r\n    attrs: componentAttrs,\r\n    componentStyle,\r\n    // $FlowFixMe\r\n    defaultProps,\r\n    foldedComponentIds,\r\n    shouldForwardProp,\r\n    styledComponentId,\r\n    target,\r\n  } = forwardedComponent;\r\n\r\n  useDebugValue(styledComponentId);\r\n\r\n  // NOTE: the non-hooks version only subscribes to this when !componentStyle.isStatic,\r\n  // but that'd be against the rules-of-hooks. We could be naughty and do it anyway as it\r\n  // should be an immutable value, but behave for now.\r\n  const theme = determineTheme(props, useContext(ThemeContext), defaultProps);\r\n\r\n  const [context, attrs] = useResolvedAttrs(theme || EMPTY_OBJECT, props, componentAttrs);\r\n\r\n  const generatedClassName = useInjectedStyle(\r\n    componentStyle,\r\n    componentAttrs.length > 0,\r\n    context,\r\n    process.env.NODE_ENV !== 'production' ? forwardedComponent.warnTooManyClasses : undefined\r\n  );\r\n\r\n  const refToForward = forwardedRef;\r\n\r\n  const elementToBeCreated: Target = attrs.as || props.as || target;\r\n\r\n  const isTargetTag = isTag(elementToBeCreated);\r\n  const computedProps = attrs !== props ? { ...props, ...attrs } : props;\r\n  const shouldFilterProps = 'as' in computedProps || 'forwardedAs' in computedProps;\r\n  const propFilterFn = shouldForwardProp || (isTargetTag && validAttr);\r\n  const propsForElement = propFilterFn || shouldFilterProps ? {} : { ...computedProps };\r\n\r\n  if (shouldFilterProps || propFilterFn) {\r\n    // eslint-disable-next-line guard-for-in\r\n    for (const key in computedProps) {\r\n      if (key === 'forwardedAs') {\r\n        propsForElement.as = computedProps[key];\r\n      } else if (key !== 'as' && (!propFilterFn || propFilterFn(key))) {\r\n        // Don't pass through non HTML tags through to HTML elements\r\n        propsForElement[key] = computedProps[key];\r\n      }\r\n    }\r\n  }\r\n\r\n  if (props.style && attrs.style !== props.style) {\r\n    propsForElement.style = { ...props.style, ...attrs.style };\r\n  }\r\n\r\n  propsForElement.className = Array.prototype\r\n    .concat(\r\n      foldedComponentIds,\r\n      styledComponentId,\r\n      generatedClassName !== styledComponentId ? generatedClassName : null,\r\n      props.className,\r\n      attrs.className\r\n    )\r\n    .filter(Boolean)\r\n    .join(' ');\r\n\r\n  propsForElement.ref = refToForward;\r\n\r\n  return createElement(elementToBeCreated, propsForElement);\r\n}\r\n\r\nfunction addRealmStyleToComponent(\r\n  target: StyledComponentWrapper<*, *>,\r\n  realm: RealmScope,\r\n  rules: RuleSet,\r\n) {\r\n  target.componentStyle.addRealmRuleSet(realm, rules);\r\n}\r\n\r\nexport default function createStyledComponent(\r\n  target: Target | StyledComponentWrapper<*, *>,\r\n  options: Object,\r\n  rules: RuleSet,\r\n  realm: ?RealmScope\r\n) {\r\n  const isTargetStyledComp = isStyledComponent(target);\r\n  const isCompositeComponent = !isTag(target);\r\n\r\n  if (isTargetStyledComp && realm) {\r\n    // $FlowFixMe\r\n    addRealmStyleToComponent(target, realm, rules);\r\n\r\n    return target;\r\n  }\r\n\r\n  const {\r\n    displayName = generateDisplayName(target),\r\n    componentId = generateId(options.displayName, options.parentComponentId),\r\n    attrs = EMPTY_ARRAY,\r\n  } = options;\r\n\r\n  const styledComponentId =\r\n    options.displayName && options.componentId\r\n      ? `${escape(options.displayName)}-${options.componentId}`\r\n      : options.componentId || componentId;\r\n\r\n  // fold the underlying StyledComponent attrs up (implicit extend)\r\n  const finalAttrs =\r\n    // $FlowFixMe\r\n    isTargetStyledComp && target.attrs\r\n      ? Array.prototype.concat(target.attrs, attrs).filter(Boolean)\r\n      : attrs;\r\n\r\n  // eslint-disable-next-line prefer-destructuring\r\n  let shouldForwardProp = options.shouldForwardProp;\r\n  // $FlowFixMe\r\n  if (isTargetStyledComp && target.shouldForwardProp) {\r\n    if (shouldForwardProp) {\r\n      // compose nested shouldForwardProp calls\r\n      // $FlowFixMe\r\n      shouldForwardProp = prop => target.shouldForwardProp(prop) && options.shouldForwardProp(prop);\r\n    } else {\r\n      // eslint-disable-next-line prefer-destructuring\r\n      shouldForwardProp = target.shouldForwardProp\r\n    }\r\n  }\r\n\r\n  const componentStyle = new ComponentStyle(\r\n    isTargetStyledComp\r\n      ? // fold the underlying StyledComponent rules up (implicit extend)\r\n        // $FlowFixMe\r\n      target.componentStyle.rules.concat(rules)\r\n      : rules,\r\n    styledComponentId\r\n  );\r\n\r\n  /**\r\n   * forwardRef creates a new interim component, which we'll take advantage of\r\n   * instead of extending ParentComponent to create _another_ interim class\r\n   */\r\n  let WrappedStyledComponent;\r\n\r\n  // eslint-disable-next-line react-hooks/rules-of-hooks\r\n  const forwardRef = (props, ref) => useStyledComponentImpl(WrappedStyledComponent, props, ref);\r\n\r\n  forwardRef.displayName = displayName;\r\n\r\n  // $FlowFixMe this is a forced cast to merge it StyledComponentWrapperProperties\r\n  WrappedStyledComponent = (React.forwardRef(forwardRef): StyledComponentWrapper<*, *>);\r\n\r\n  WrappedStyledComponent.attrs = finalAttrs;\r\n  WrappedStyledComponent.componentStyle = componentStyle;\r\n  WrappedStyledComponent.displayName = displayName;\r\n  WrappedStyledComponent.shouldForwardProp = shouldForwardProp;\r\n\r\n  // this static is used to preserve the cascade of static classes for component selector\r\n  // purposes; this is especially important with usage of the css prop\r\n  WrappedStyledComponent.foldedComponentIds = isTargetStyledComp\r\n    ? // $FlowFixMe\r\n    Array.prototype.concat(target.foldedComponentIds, target.styledComponentId)\r\n    : EMPTY_ARRAY;\r\n\r\n  WrappedStyledComponent.styledComponentId = styledComponentId;\r\n\r\n  // fold the underlying StyledComponent target up since we folded the styles\r\n  WrappedStyledComponent.target = isTargetStyledComp\r\n    ? // $FlowFixMe\r\n    target.target\r\n    : target;\r\n\r\n  // $FlowFixMe\r\n  WrappedStyledComponent.withComponent = function withComponent(tag: Target) {\r\n    const { componentId: previousComponentId, ...optionsToCopy } = options;\r\n\r\n    const newComponentId =\r\n      previousComponentId &&\r\n      `${previousComponentId}-${isTag(tag) ? tag : escape(getComponentName(tag))}`;\r\n\r\n    const newOptions = {\r\n      ...optionsToCopy,\r\n      attrs: finalAttrs,\r\n      componentId: newComponentId,\r\n    };\r\n\r\n    return createStyledComponent(tag, newOptions, rules);\r\n  };\r\n\r\n  // $FlowFixMe\r\n  Object.defineProperty(WrappedStyledComponent, 'defaultProps', {\r\n    get() {\r\n      return this._foldedDefaultProps;\r\n    },\r\n\r\n    set(obj) {\r\n      // $FlowFixMe\r\n      this._foldedDefaultProps = isTargetStyledComp ? merge({}, target.defaultProps, obj) : obj;\r\n    },\r\n  });\r\n\r\n  if (process.env.NODE_ENV !== 'production') {\r\n    checkDynamicCreation(displayName, styledComponentId);\r\n\r\n    WrappedStyledComponent.warnTooManyClasses = createWarnTooManyClasses(\r\n      displayName,\r\n      styledComponentId\r\n    );\r\n  }\r\n\r\n  // $FlowFixMe\r\n  WrappedStyledComponent.toString = () => `.${WrappedStyledComponent.styledComponentId}`;\r\n\r\n  if (isCompositeComponent) {\r\n    hoist(WrappedStyledComponent, (target: any), {\r\n      // all SC-specific things should not be hoisted\r\n      attrs: true,\r\n      componentStyle: true,\r\n      displayName: true,\r\n      foldedComponentIds: true,\r\n      shouldForwardProp: true,\r\n      self: true,\r\n      styledComponentId: true,\r\n      target: true,\r\n      withComponent: true,\r\n    });\r\n  }\r\n\r\n  return WrappedStyledComponent;\r\n}\r\n"],"names":["nodes","insertRule","names","id","stylisPlugins","flatten","React","isTargetStyledComp"],"mappings":"k3FAsF0BA,gHAgBxBC,WAAA,44DC5DQC,yvBA+B8BC,iOAkBVA,yvTC5DiBC,qgGC1BM,qMCiBjCC,gCAEVF,qjCCyCEG,0nTCiIJC"}